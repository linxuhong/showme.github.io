## 一道Java测试题的思考 double float  


### 关于double float的原题目如下 
>>  float a = 0.125f; 
>   double b = 0.125d; 
>   System.out.println((a - b) == 0.0); 
>   代码的输出结果是什么？
>>  A. true
>>  B. false


### ( 0.125f - b = 0.125d )   == 0.0  结果是   ?
1. ( 0.125f - b = 0.125d )   == 0.0 的值 为 `true `

```java

    System.out.println("//------test 0.125f  0.125d ---");
    float a = 0.125f;
    double b = 0.125d;
    System.out.println((a - b) == 0.0);
    System.out.println(a);
    System.out.println(b);
    
    //------test 0.125f  0.125d ---
           true
           0.125
           0.125

```
 

### 继续看另一个现象 

1. 记得   0.99999999f==1f  为` true`   而 0.9f==1f为 `false
`
```java
    
    System.out.println("// 0.99999999f==1f   " );
    System.out.println(0.99999999f==1f);
    
    System.out.println("//0.9f==1f   " );
    System.out.println(0.9f==1f);
    
    // 0.99999999f==1f   
    true
    //0.9f==1f   
    false
```
> 要明白这些，首先要搞清楚float和double在内存结构



### 十进制，二进制怎么转换
```java 
    1.0（十进制）
        ↓
    00111111 10000000 00000000 00000000（二进制）
        ↓
    0x3F800000（十六进制）
```

```java 
    0.99999999（十进制）
        ↓
    00111111 10000000 00000000 00000000（二进制）
        ↓
    0x3F800000（十六进制）
```

   ![下载包](https://ask.qcloudimg.com/http-save/yehe-3718739/q3qhlg38q.png)
   ![下载包](https://ask.qcloudimg.com/http-save/yehe-3718739/z8g4yvpfgq.png)

1、符号部分（S）

0-正  1-负

2、阶码部分（E）（指数部分）：

- 对于float型浮点数，指数部分8位，考虑可正可负，因此可以表示的指数范围为-127 ~ 128
- 对于double型浮点数，指数部分11位，考虑可正可负，因此可以表示的指数范围为-1023 ~ 1024
3、尾数部分（M）：

浮点数的精度是由尾数的位数来决定的：

- 对于float型浮点数，尾数部分23位，换算成十进制就是 2^23=8388608，所以十进制精度只有6 ~ 7位；
- 对于double型浮点数，尾数部分52位，换算成十进制就是 2^52 = 4503599627370496，所以十进制精度只有15 ~ 16位
所以对于上面的数值0.99999999f，已经超过了float型浮点数据的精度范围，出问题也是在所难免的。


### 进制转换
32位单精度二进制 = [1个符号位] [8个阶码位] [23个尾数位]

64位单精度二进制 = [1个符号位] [11个阶码位] [52个尾数位]

小数 = [正负符号位]  [整数部分] . [小数部分] 


- 第一步：符号位，负用1表示，正的用 0，所以[1个符号位] 是1
- 第二步：整数直接转换成二进制
　　- 十进制36 = 二进制0010 0100
- 第三步：将小数转换成二进制
　　- 十进制0.35 = 二进制0101 1001 1001 1001 10001 1001 其中1001循环
    - 计算过程：  
      - 0.35 x 2 = 0.7取整得0 取上次结果的小数部分乘以2
      - 0.7 x 2 = 1.4取整得1  取0.7的小数部分即0.7乘以2
      - 0.4 x 2 = 0.8取整得0  取1.4的小数部分即0.4乘以2
      - 0.8 x 2 = 1.6取整得1  取1.6的小数部分0.6乘以2
      - 0.6 x 2 = 1.2取整得1  取上次结果的小数部分乘以2
      - 0.2 x 2 = 0.4取整得0
      - 0.4 x 2 = 0.8取整得0
       ...循环
- 第三步：移动小数点计算阶码
　- 整数二进制.小数二进制
　  - =0010 0100.0101 1001 1001 1001 10001 1001
　- 移动小数点，使二进制变成1.xxx*2n形式（规格化）
　  - =001.0 0100 0101 1001 1001 1001 10001 1001*25
  - 去掉1.xxx前面的0
    - =1.0 0100 0101 1001 1001 1001 10001 1001*25
  - 指数的真值是5加上(8位阶码位移码偏移量127)=132
     - 5 + 127 = 132
     - 132的二进制是1000 0100 所以[8个阶码位]是1000 0100
     
- 第四步：取1.xxx形式小数点后23位得到[23个尾数位]
     - =0 0100 0101 1001 1001 1001 10001 1001 .. （取23位）

第五步：组合二进制 32位单精度二进制 
    - = [1个符号位] [8个阶码位] [23个尾数位]
    - = [1] [1000 0100] [0 0100 0101 1001 1001 1001 10001 1001 .. （取23位）]
    - = 1 1000 0100 0 0100 0101 1001 1001 1001 10001 1001 .. （取23位）


### Java的数字是用什么码球表示的，写个例子证明一下
```java

// 11111111111111111111111110000101
int tt =- 123;
System.out.println(Integer.toBinaryString(tt));

```

### 回到原题
float a = 0.125f;
double b = 0.125d; 
a-b == 0.0
为什么相等，只不过恰好在二进制层面满足了要求。
实际上你是可以造出这样看起来相等的数据的

```java

    System.out.println("//------test ");
    System.out.println(3.15f - 3.15d);
    System.out.println(3.25f - 3.25d);
    System.out.println(3.215f - 3.215d);
    System.out.println(3.625f - 3.625d);
    System.out.println(3.250f - 3.250d);``
    
    //------test 
    9.536743172944284E-8
    0.0
    -8.583068833445395E-8
    0.0
    0.0
    
```

我想你应该发现了什么规律了.

### 附10道{Java测试}原题 ：

 ```java
    1
    
    float a = 0.125f; double b = 0.125d; System.out.println((a - b) == 0.0); 代码的输出结果是什么？
    
    A. true
    B. false
    
    2
    
    double c = 0.8; double d = 0.7; double e = 0.6; 那么 c-d 与 d-e 是否相等？
    
    A. true
    B. false
    
    3
    
    System.out.println(1.0 / 0); 的结果是什么？
    
    A. 抛出异常
    B. Infinity
    C. NaN
    
    4
    
    System.out.println(0.0 / 0.0); 的结果是什么？
    
    A. 抛出异常
    B. Infinity
    C. NaN
    D. 1.0
    
    5
    
    >> 和 >>> 的区别是？
    
    A. 任何整数没有区别
    B. 负整数一定没有区别
    C. 浮点数可以 >> 运算，但是不可以 >>> 运算
    D. 正整数一定没有区别
    
    6
    
    某个类有两个重载方法：void f(String s) 和 void f(Integer i)，那么 f(null) 的会调用哪个方法？
    
    A. 前者
    B. 后者
    C. 随机调用
    D. 编译出错
    
    7
    
    某个类有两个重载方法：void g(double d) 和 void g(Integer i)，那么 g(1) 的会调用哪个方法？
    
    A. 前者
    B. 后者
    C. 随机调用
    D. 编译出错
    
    8
    
    String a = null; switch(a) 匹配 case 中的哪一项？
    
    A. null
    B. "null"
    C. 不与任何东西匹配，但不抛出异常
    D. 直接抛出异常
    
    9
    
    <String, T, Alibaba> String get(String string, T t) { return string; } 此方法：
    
    A. 编译错误，从左往右第一个 String 处
    B. 编译错误，T 处
    C. 编译错误，Alibaba 处
    D. 编译正确
    
    10
    
    HashMap 初始容量 10000 即 new HashMap(10000)，当往里 put 10000 个元素时，需要 resize 几次（初始化的那次不算）？
    
    A. 1 次
    B. 2 次
    C. 3 次
    D. 0 次
```

### 官方给的答案

`ABBCD DADDD`
